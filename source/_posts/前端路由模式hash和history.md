---
title: 前端路由模式hash和history
---

最近工作时，遇到了页面关于页面跳转的问题，就继续了解了下两种路由模式的异同。
<!-- more -->

## 前端路由实现方式

**SPA：**即**单页面应用**(Single Page Application)。单页应用程序 (SPA) 是加载单个 `HTML` 页面并在**用户与应用程序交互时**动态更新该页面的 `Web` 应用程序。浏览器一开始会加载必需的 `HTML` 、 `CSS` 和 `JavaScript` ，所有的操作都在这张页面上完成，都由 `JavaScript` 来控制。

在单页面web网页中, 单纯的**浏览器地址改变, 网页不会重载**，如单纯的hash网址改变网页不会变化，因此我们的路由主要是`通过监听事件，并利用js实现动态改变网页内容`，有两种实现方式：

`hash模式`：监听浏览器地址hash值变化，执行相应的js切换网页；

`history模式`：利用history API实现url地址改变，网页内容改变； 它们的区别最明显的就是hash会在浏览器地址后面增加#号，而history可以自定义地址。



## Hash模式

### 定义

`hash` 模式是一种把前端路由的路径用井号 `#` 拼接在真实 `url` 后面的模式。当井号 `#` 后面的路径发生变化时，浏览器并不会重新发起请求，而是会触发 `onhashchange` 事件。

```
//http://127.0.0.1:8001/01-hash.html?a=100&b=20#/aaa/bbb

location.protocal // 'http:'
localtion.hostname // '127.0.0.1'
location.host // '127.0.0.1:8001'
location.port //8001
location.pathname //'01-hash.html'
location.serach // '?a=100&b=20'
location.hash // '#/aaa/bbb'
```

### 特点

- hash指的是地址中#号以及后面的字符，也称为**散列值**。hash也称作**锚点**，本身是用来做页面跳转定位的。如`http://localhost/index.html#abc`，这里的#abc就是hash
- `hash` 可以改变 `url` ，但是不会触发页面重新加载（hash的改变是记录在 `window.history` 中，**`hash` 永远不会提交到 `server` 端，所以改变hash，不会重新加载页面**）。也就是说，所有页面的跳转都是在客户端进行操作。因此，这并不算是一次 `http` 请求，所以这种模式不利于 `SEO` 优化。`hash` 只能修改 `#` 后面的部分，所以只能跳转到与当前 `url` 同文档的 `url` 。

- `hash` 通过 `window.onhashchange` 的方式，来监听 `hash` 的改变，借此实现无刷新跳转的功能。当散列值改变时，可以通过 location.hash 来获取和设置hash值；

## History模式

### 定义

`history API` 是 `H5` 提供的新特性，允许开发者**直接更改前端路由**，即更新浏览器 `URL` 地址而**不重新发起请求**。

| API                                       | 定义                                                         |
| ----------------------------------------- | ------------------------------------------------------------ |
| history.pushState(data, title [, url])    | pushState主要用于**往历史记录堆栈顶部添加一条记录**。各参数解析如下：**①data**会在onpopstate事件触发时作为参数传递过去；**②title**为页面标题，当前所有浏览器都会忽略此参数；③**url**为页面地址，可选，缺少时表示为当前页地址 |
| history.replaceState(data, title [, url]) | 更改当前的历史记录，参数同上； 上面的pushState是添加，这个更改 |
| history.state                             | 用于存储以上方法的data数据，不同浏览器的读写权限不一样       |
| window.onpopstate                         | 响应pushState或者replaceState的调用                          |
| history.back()                            | 移动到上一个网址，等同于点击浏览器的后退键                   |
| history.forward()                         | 移动到下一个网址，等同于点击浏览器的前进键                   |
| history.go()                              | 接受一个整数作为参数，以当前网址为基准，移动到参数指定的网址。如果参数超过实际存在的网址范围，该方法无效果；如果不指定参数，默认参数为0，相当于刷新当前页面。 |

### 特点

- 新的 `url` 可以是与当前 `url` 同源的任意 `url` ，也可以是与当前 `url` 一样的地址，但是这样会导致的一个问题是，会把**重复的这一次操作**记录到栈当中。

- 通过 `history.state` ，添加任意类型的数据到记录中。

- 可以额外设置 `title` 属性，以便后续使用。

- 通过 `pushState` 、 `replaceState` 来实现无刷新跳转的功能。

## 对比

| hash                                                         | history                                                      |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 有 # 号                                                      | 没有 # 号，**更美观**                                        |
| 能够**兼容到IE8**                                            | 只能兼容到IE10                                               |
| 实际的url之前使用哈希字符，这部分url不会发送到服务器，**不需要在服务器层面上进行任何处理** | 每访问一个页面都需要服务器进行路由匹配生成 html 文件再发送响应给浏览器，消耗服务器大量资源 |
| 刷新不会存在 404 问题                                        | **浏览器直接访问嵌套路由时，会报 404 问题。**                |
| **不需要服务器任何配置**                                     | 需要在服务器配置一个回调路由                                 |
|                                                              |                                                              |

推荐使用hash模式，但hash模式也有不足

1、hash 模式中的 # 也称作锚点，这里的的 # 和 css 中的 # 是一个意思，**所以在 hash 模式内，页面定位会失效。**

2、hash改变不进行http请求，**不利于 SEO**（搜索引擎优化）。

3、**白屏时间问题**。浏览器需要等待 JavaScript 文件加载完成之后渲染 HTML 文档内容，用户等待时间稍长。

